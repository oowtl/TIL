# Numpy

> python 에서 벡터, 행렬 등 수치 연산을 수행하는 선형대수 라이브러리
>
> 선형대수 관련 수치 연산을 지원한다.
>
> 내부적으로는 C로 구현되어 있어서 연산이 빠르다.
>
> Scipy 와 함께사용하면 MATLAB에 버금가는 기능을 지원한다.



- 출처
  - https://laboputer.github.io/machine-learning/2020/04/25/numpy-quickstart/



## 기초 개념

- Numpy 에서 오브젝트는 동차(Homogeneous) 다차원 배열이라고 한다.
  단순히 다차원 배열로 표현한다고 이해해도 좋다.
  - Homogeneous
    - 선형대수학에서 나오는 개념.
      같은 카테고리의 결과가 나온다는 의미인 듯 하다...
- Numpy 에서는 모든 배열의 값이 기본적으로 같은 타입이어야 한다.
- Numpy 에서는 각 차원(Dimension)을 축(axis)이라고 표현한다.



### 예시

1. `[1, 2, 1]`
   - 축 : 1개
   - 요소 : 3개
   - 길이 : 3
2. `[ [1, 0, 0],
   [0, 1 ,2]]`
   - 축 : 2개
   - 1번째 축의 길이 : 2
   - 2번째 축의 길이 : 3



### 속성

```python
a = np.arange(15).reshape(3, 5)
print(a)
[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]]
```

- (3, 5) 크기의 배열을 생성한다.



```python
print(a2.shape) # (3, 5)
print(a2.ndim) # 2
print(a2.dtype) # int32
print(a2.itemsize) # 4
print(a2.size) # 15
print(type(a2)) # <class 'numpy.ndarray'>
```

- 속성
  1. `ndarray.shape` : 배열의 각 축의 크기
  2. `ndarray.ndim` : 축의 갯수
  3. `ndarray.dtype` : 각 요소의 타입
  4. `ndarray.itemsize` : 각 요소의 타입의 bytes 크기
  5. `ndarray.size` : 전체 요소의 갯수



## 배열 생성하기

### 1. `np.array()`

`np.array()` 를 이용해서 python 에서 사용하는 튜플이나 리스트를 입력하여 `numpy.ndarray`를 만들 수 있다.

```python
a3 = np.array([2, 3, 4])
print(a3) # [2 3 4]
print(a3.dtype) # int32

b3 = np.array([1.2, 3.5, 5.1])
print(b3.dtype) # float64
```

- 주의할 점은 연속된 데이터를 줘야한다.



#### 옵션

1. `np.zeros(shape)` : 0으로 구성된 N차원 배열 생성
2. `np.ones(shape)` : 1로 구성된 N차원 배열 생성
3. `np.empty(shape)` : 초기화되지 않은 N차원 배열 생성



```python
print(np.zeros((3, 4)))
# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]

print(np.ones((2, 3, 4), dtype=np.int16))
# [[[1 1 1 1]
#   [1 1 1 1]
#   [1 1 1 1]]
#
#  [[1 1 1 1]
#   [1 1 1 1]
#   [1 1 1 1]]]

print(np.empty((2, 3)))
# [[1.39069238e-309 1.39069238e-309 1.39069238e-309]
#  [1.39069238e-309 1.39069238e-309 1.39069238e-309]]
```



### 2. `np.arrange()` & `np.linspace()`

1. `np.arrange()` : N 만큼 차이나는 숫자 생성
2. `np.linspace()` : N 등분한 숫자 생성



```python
# 10 ~ 30 5씩 차이
print(np.arange(10, 30, 5))
# [10 15 20 25]

# 0 ~ 2 0.3 씩 차이
print(np.arange(0, 2, 0.3))
# [0.  0.3 0.6 0.9 1.2 1.5 1.8]

# 0 ~ 99 까지 100 등분
x = np.linspace(0, 99, 100)
print(x)
#[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15. 16. 17.
#18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35.
#36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53.
#54. 55. 56. 57. 58. 59. 60. 61. 62. 63. 64. 65. 66. 67. 68. 69. 70. 71.
#72. 73. 74. 75. 76. 77. 78. 79. 80. 81. 82. 83. 84. 85. 86. 87. 88. 89.
#90. 91. 92. 93. 94. 95. 96. 97. 98. 99.]
```



## 기본 연산

```python
a4 = np.array( [20, 30, 40, 50])
b4 = np.arange(4)

print(b4) # [0 1 2 3]

c4 = a4 - b4
# 각 원소들에 대해서 뺄샘
print(c4) # [20 29 38 47]

# 각 원소들에 대해서 제곱
print(b4**2) # [0 1 4 9]

# 각 원소에 *10
print(10*np.sin(a4)) # [ 9.12945251 -9.88031624  7.4511316  -2.62374854]

# 각 원소에 대해서 조건을 달아서 Boolean
print(a4 < 35) # [ True  True False False]
```





## 인덱싱, 슬라이싱

```python
a5 = np.arange(10) ** 3

print(a5) # [  0   1   8  27  64 125 216 343 512 729]

print(a5[2]) # 8

# 2 ~ 4 번 인덱스
print(a5[2:5]) # [ 8 27 64]

# 0 ~ 5 번 에서 2step에 해당하는 인덱스
a5[:6:2] = 1000
print(a5) # [1000    1 1000   27 1000  125  216  343  512  729]
```





### 선택하기

```python
a6 = np.arange(10).reshape(2,5)
print(a6)
# [[0 1 2 3 4]
#  [5 6 7 8 9]]

print(a6[1,2]) # 7
```



### 형태 바꾸기

- `reshape()`
  - 기존의 데이터는 유지하고 차원과 형상을 바꿔준다.
  - 바꾸는 개수가 나눠지지 않는다면 `ValueError: cannot reshape array of size` 에러를 발생시킨다.

```python
a7 = np.array([
    [1,2,3,4],
    [5,6,7,8]
])

print(a7)
# [[1 2 3 4]
#  [5 6 7 8]]

b7 = a7.reshape((2,2,2))

print(b7)
# [[[1 2]
#   [3 4]]
#
#  [[5 6]
#   [7 8]]]
```

