# Code By Java



- 염두에 둘 것!
  - 어떻게 인터페이스를 사용하는지 생각해보자.
  - 객체지향 설계가 어떻게 작동하는지 생각해보자.



## 회원 도메인

- 도메인 협력 관계
  - 기획자도 볼 수 있는 그림
- 클래스 다이어그램
  - 도메인 협력관계를 좀 더 자세하게 만든 것
  - 클래스 들만 분석해서 볼 수 있는 것
  - 각각 구현체 그림들은 동적으로, 실행환경에 따라서 다 달라진다.
- 객체 다이어그램
  - 따라서 각 상황에 맞는, 실제로 각 객체가 어떤 것을 바라보는 지에 대한 명시가 필요하다.



- 인터페이스가 아웃풋에 대한 명시니까 그것을 구현하는 과정은 어떤 방식이던지 상관이 없다는 것을 염두해두자.
- 결국 어떤 기능에 대해서 요구하는 것들을 명시적으로 대할 수 있다.



### 구조를 분석해보자

- 인터페이스는 어떤 결과가 필요하다는 것을 명시하는 것이다. 그러니까 이 기능에 대해서는 이러한 아웃풋이 나와야한다는 것이다.
  일단 그 결과가 제대로 나온다면 과정은 어떤 방식으로 되던지 간에 큰 상관이 없다는 것이 이것의 핵심!!

  - 인터페이스에 맞춰서 각 구현 클래스들을 만들어내는 것이다...

- 인터페이스 만으로는 사실 뭔가를 할 수는 없다. 인터페이스를 보면 그냥 결과에 대한 것들만 있으니까

  - 그래서 인터페이스를 받은 구현체가 필요해진다.

  - 인터페이스 자체도 필요하지만 그것에 추가해서 구현체까지 필요하다는 뜻이다.

  - ```java
    MemberService memberService = new MemberServiceImpl();
    ```

    - 이런 방식으로 인터페이스 자체도 필요하고, 구현체도 필요하다는 것이다.
    - 하나만 필요하지는 않다는 것이다.

- 추가적으로는 바라본다는 것이, 별다른 것이 없고 사용한다는 느낌도 있는 것 같다.
  위의 코드에서 멤버 서비스를 사용한다는 것이니까.
  어찌됫든 `public class { ... }` 에 속하는 것일테니 해당 class 에서 사용한다는 느낌인 것 같다.





### test

- 현대 프로그래밍은 test 코드가 필수적이다. 항상 출력으로만 알 수는 없기 때문이다.
- test 의 문법
  - given
    - 무엇이 주어지는 상황인지 체크한다.
  - when
    - 주어진 상황으로 어떻게 할지를 본다.
  - then
    - 무엇을 하고 난 다음의 상황을 체크한다.

 

## 좋은 설계

- 단일 체계 원칙이라는 것은 각각을 참조를 하는데 그 참조하는 값이 오로지 참조하는 곳에서만 변경이 되는 것이다.
  - 내가 가격을 산정하는데, 할인되는 가격을 알고 싶다면??
    - 총 가격을 산정하는 곳에서 이리저리 조정하는 것이 아니라 할인에 대한 항목들을 따로, 다른 공간에서 계산을 수행해야 한다는 것이다.
    - 그러면 할인에 대한 정책들이 수정될 때는 그곳에서만 수정하면 되니까 유지보수도 원활하게 할 수 있다.



## `assertThat`

- 이 메서드는 Junit 과 assertJ 라는 곳 두개에서 사용되는 것이다.

  - 이 설명은 assertJ 에 대한 내용이다.

- 두 값(객체)를 비교할 때 주로 사용하는 것이다.

- 구조

  - ```java
    assertThat(T actual).isEqualTo(expected)
    ```

    - 파라미터 : 비교 대상의 실제 값
    - 뒤 : 비교하는 방법과 비교하는 대상











## Meet Error



###  non-static variable

- `non-static variable cannot be referenced from a static context`

  - static 으로 선언되지 않은 변수는 static 컨텍스트 (함수) 로 부터 참조될 수 없다.
  - static 으로 선언된 함수 내에서 static 으로 선언되지 않은 변수를 사용했다는 오류메세지이다.

- ```java
  OrderService orderService = new OrderServiceImpl();
  
  // Error
  Order order = OrderService.createOrder(memberId, "itemA", 10000);
  
  // Run
  Order order = orderService.createOrder(memberId, "itemA", 10000);
  ```

  - 여기에서 나는 `createOrder`를 하기 위해서 인터페이스에다가 하고 있었다.
  - 선언해준 `orderService` 에 해주는 것이 맞았다.