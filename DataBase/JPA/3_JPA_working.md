# JPA3. 내부 동작



- jpa 에서 중요한 것
  - 객체와 관계형 데이터베이스 매핑하기
  - 영속성 컨텍스트
    - 실제 jpa가 내부에서 어떻게 동작해??



## 영속성 컨텍스트

- 엔티티를 영구 저장하는 환경
  - DB에 저장하는 것이 아니라 영속성 컨텍스트라는 곳에 저장을 한다.
- 영속성 컨텍스트는 논리적인 개념이다.
  - 눈에 보이는 것은 아니다.
- 엔티티 매니저를 통해서 영속성 컨텍스트로 접근한다.



### 엔티티 매니저 팩토리와 엔티티 매니저

- 엔티티 매니저 팩토리는 요청이 올 떄마다 엔티티 매니저를 생성한다.
- 엔티티 매니저는 데이터베이스 커넥션을 사용해서 데이터베이스를 사용한다.



### 엔티티의 생명주기

- 비영속 ( new )
- 영속 (managed)
- 준영속
- 삭제



#### 비영속 상태

- 객체를 생성한 상태
- 셋팅만 한 상태
- JPA와 전혀 관계없는 상태이기 때문에 비영속 상태



#### 영속 상태

- 객체를 생성한 상태, 비영속 상태에서 객체를 저장하도록 하여 영속 컨텍스트에 들어가도록 한 것
- 영속 상태라고 바로 쿼리가 날라가는 것이 아니다.
  트랜잭션이 커밋되는 시점에서 쿼리가 날라간다.



#### 준영속, 삭제

- 영속 컨텍스트에서 내리는 경우, 삭제를 하는 경우를 말한다.



### 영속성 컨텍스트의 이점

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경감지
- 지연로딩



#### 1차 캐시

- 설명
  - DB 를 사용할 때, 1차 캐시를 먼저 검색한 후에 없다면 DB로 간다.
  - 영속성 컨텍스트의 1차캐시
    - 아이디를 키로 하고 객체 자체를 밸류로 하는 map으로 한다.
  - 조회를 할 때
    - 요청을 받으면 DB로 가는 것이 아니라 먼저 1차 캐시에서 찾아서 간다.
    - 만약에 없다면, 1차캐시에서 찾고다른 곳에서 찾는다.
      찾은 결과는 1차 캐시에서 찾아서 저장하고 반환한다.
    - 큰 도움은 안된다. 각 비즈니스 단위 당 트랜잭션은 하나만 실행된다.
      그래서 상당히 짧은 순간에만 공유를 할 수 있는 것이다. 따라서 큰 도움이 되지는 않는다.



#### 동일성 보장

- 설명
  - 1차 캐시로 인해서 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다.
  - 같은 것인지 비교하는 것을 지원해준다.
    - 동일한 것인지 비교해주는 것!



#### 트랜잭션을 지원하는 쓰기 지연

- 순서

  1. 트랜잭션 시작
  2. persist를 통해서 영속성 컨텍스트로 넘긴다.
     1. 1차 캐시에 넣는다.
     2. 쓰기지연 SQL 저장소에 SQL문에 넣는다.
        - 바로 insert SQL 을 데이터베이스에 보내지 않는다.
  3. 트랜잭션을 커밋하면 데이터베이스에 SQL문으로 보낸다.
     1. 커밋
     2. 쓰기지연 SQL 저장소에 있던 것들이 DB에 날라간다 == flush
     3. 트랜잭션 커밋 

- 바로바로 SQL로 가버리면 최적화를 할 수 있는 요소가 없어진다.

- 설정

  - ```properties
    <property name="hibernate.jdbc.batch_size" value="10"/>
    ```



#### 변경감지

- jpa 의 목적은 자바의 컬렉션처럼 다루도록 하는 것이다.

- 변경을 하고 나서 저장을 하도록 명시하는 것이 아니라, 자동으로 값을 변경한다.

- 순서

  1. 커밋을 하면 내부적으로 flush 라는 것이 실행된다.

  2. 앤티티와 스냅샷을 비교한다.(1차 캐시 안)
     - 스냅샷 : 값을 읽어올 때, 그 최초시점의 상태를 떠오는 것
  3. 트랜잭션이 커밋될 때 JPA가 스냅샷과 엔티티를 비교한다.
  4. 변경사항을 SQL 쿼리로 쓰기지연 SQL 저장소에 넣어둔다.
  5. DB에 쿼리문을 보낸다.



## 플러시 (Flush)

- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것
- 동작
  - 변경을 감지한다.
  - 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록한다.
  - 쓰기 지연 SQL 저장소의 쿼리를 데이터 베이스에 날린다.
- DB에 커밋을 하는 것은 아니다.
- 특징
  - 영속성 컨텍스트를 비우는 것이 아니다.
  - 변경 내용을 데이터베이스에 동기화한다.
  - 트랜잭션이라는 작업 단위가 중요하다는 것!
    - 커밋 직전에만 동기화하면 된다.



### 플러시는 어떻게 하나요?

- 직접호출
  - `em.flush()`
- 트랜잭션 커밋 (자동)
- JPQL 쿼리 사용 (자동)
  - 쿼리를 통해서 사용하다보면 지연 SQL 저장소에 있는 것을 사용하는 경우가 있을 수도 있다.
    만약, 아직 쓰기지연 SQL에 있는 것을 가져오려고 하면 어떻게 될까??? 문제가 생길 수도 있다.
    따라서 JPQL 은 처음부터 플러시를 날려버린다.



### 플러시를 하면?

- 플러시를 해도 1차 캐시는 지워지지 않는다.
  오로지 쓰기 지연 SQL 저장소에 있는 것을 DB에 반영하는 과정이다.



### 플러시 모드

- `em.setFlushMode(FlushModeType.AUTO)`
  - 커밋이나 쿼리 실행 시 플러시 (default)
- `em.setFlushMode(FlushModeType.COMMIT)`
  - 커밋할 때만 플러시





## 준영속 상태

- 속성
  - 영속에서 준영속으로 갈 수 있는 상태
  - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리됨
- 영속상태
  - em.persist 를 한 상태, 올라간 상태
  - em.find 를 하는 상황에서 DB에서 가져와서 1차캐시에 올린 상태
- 방법
  - `em.detach(entity)`
    - JPA가 더이상 관리를 하지 말라고 하는 것
  - `em.clear()`
    - 통 째로 다 지워버리는 것
  - `em.close()`
    - 영속성 컨텍스트를 종료한다.
