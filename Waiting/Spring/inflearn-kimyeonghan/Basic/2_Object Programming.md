# 좋은 객체 지향 프로그래밍이 뭐야???



## 객체 지향 프로그래밍

- 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나서 여러개의 독립된 단위, 객체들의 모임으로 파악하고자 하는 것
- 각각의 객체는 메세지를 주고받고 데이터를 처리할 수 있다.
- **객체 지향 프로그래밍은 유연하고 변경이 용이**하게 만들어서 대규모 소프트웨어 개발에 많이 사용된다.
  - 레고 블럭을 조립하듯이 컴포넌트를 쉽고 유연하게 갈아 끼울 수 있는 방법



### 다형성 (Polymorphism)

- 다형성의 비유
  - 역할과 구현으로 세상을 구분한다.
    - 역할이 인터페이스이고 구현이 인터페이스를 만드는 것이다.
    - 자동차와 운전자
      - 자동차가 바뀐다고 해서 운전자가 운전을 할 수 없나???
        - 아니지! 자동차가 바뀐다고 해서 자동차를 운전하는 방법이 달라지는 것은 아니다.
          왜?자동차를 만들 때, 자동차의 인터페이스를 따라서 만들기 때문이다.
          그런데 왜 이렇게 자동차의 인터페이스를 같이 할까?
          왜냐하면 운전자 때문이다. 운전자를 위해서.
          내부적으로 바뀌더라도 운전자 인터페이스만 똑같으면 운전자는 운전을 할 수 있다.
          새로운 것이 나오더라도 자동차 역할만 구현해놓으면 대상을 바꾸지 않고 새로운 것을 만들 수 있다.
      - **새로운 것이 나와도 클라이언트는 새로운 것을 배우지 않아도 된다.**
    - 역할은 어쩌면 일종의 결과, 요구치 와 같다고 생각이 든다. 그 결과를 얻기 위한 방법으로서 구현이 나타나는데 그 방법이 어떻게 되는지는 역할의 측면에서는 상관이 없다.

#### 역할과 구현의 분리

- 역할과 구현으로 구분하면 세상이 단순해지고 유연해지며 변경도 편리해진다.
- 장점
  - 클라이언트는 대상의 역할만 알면된다.
  - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
  - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
  - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
- 자바언어
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체
  - 객체를 설계할 때 역할을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기
    - 역할이 구현보다 더 중요하고 핵심적이다.
  - 객체를 설계할 때 역할과 구현을 명확하게 분리해야한다.



#### 객체의 협력이라는 관계를 생각하자

- 혼자있는 객체는 없다.
- 클라이언트 : 요청, 서버 : 응답
  - 중요한 것은 클라이언트 이다.
- 수 많은 객체 클라이언트와 객체 서버느 서로 협력 관계를 가진다.



#### 자바 언어의 다형성

- 자바는 다형성을 어떻게 생각하는가?

- 오버라이딩

  - 자바의 기본 뭄법

  - 오버라이딩 된 메서드가 실행이 되는 것을 말한다.

  - 인터페이스에서 save() 메서드를 실행하라고 하면 실행되는 시점에서 해당 인터페이스를 상속하는 다른 객체들의 save() 메서드를 실행시키도록 유연하게 변경할 수 있다.

  - ```java
    pulbic class MemeberService {
      private MemberRepository memberRepository = new MemoryRepository();
    }
    ```



#### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 **실행 시점에 유연하게 변경**할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야 한다.
- **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.**



#### 역할과 구현을 분리한다.

- 유연하고 변경이 용이하다.
- 확장이 가능한 설계를 가진다.
- 확장 가능한 설계가 가능하다.
- 클라이언트에 영향을 주지않는 변경이 가능하다.
- **인터페이스를 안정적으로 잘 설계하는 것이 중요하다.**
  - 이 역할을 잘 설계하는 것이 중요하다.



##### 한계점

- 인터페이스 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.
  - 자동차가 비행기로?
  - 대본 자체가 변경된다면??
- **인터페이스를 가장 변화가 없도록 잘 설계하는 것이 중요하다.**
  - API 설계도 잘하는 것이 좋은 것이다.



## 스프링과 객체 지향!

- 스프링은 다형성을 극대화해서 이용할 수 있도록 도와준다.
- 제어의 역전(IOC), 의존관계 주입(DI) 은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
  - 스프링이 하는 것은 각각의 것들을 레고를 쌓는 것처럼 하는 것을 통해서 도와주는 것이다.



## 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- 5가지 원칙
  - SRP : 단일 책임 원칙
  - OCP : 개방 폐쇄 원칙
  - LSP : 리스코프 치환 원칙
  - ISP : 인터페이스 분리 원칙
  - DIP : 의존관계 역전 원칙



### SRP 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 모호하다.
  - 클수도 작을수도
  - 문맥과 상황에 따라 다르다.
- 중요한 판단의 기준은 변경이다.
  변경이 있을 때, 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
  - 적절하게 하는 것이 중요하다.



### OCP 개방 폐쇄 원칙

- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.
- 기능 확장을 어떻게 변경없이 할 수 있을까??
  - **다형성**을 활용해볼 수 있다.
  - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현한다. 



#### 문제점

```java
pulbic class MemberService {
//  private MemberServiceRepository memberRepository = new MemoryMemberRepository();
  private MemberRepository memberRepository = new JdbcMemberRepository();
}
```

- MemberService 가 인터페이스이며 클라이언트이다.
- 클라이언트가 구현 클래스를 직접 선택해야한다.
- 구현 객체를 변경하기위해서는 클라이언트 코드를 변경해야한다.
  - 다형성을 사용하지만 OCP 원칙을 지킬 수 없다.
- 문제 극복법
  - 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
    - 이걸 해주는 것이 spring container 같은 것들이다.



### LSP 리스코프 치환원칙

- 인터페이스에 대한 구현체가 있다. 어떤 기능을 구현하는 것에 있어서 인터페이스의 규약을 맞추는 것이다.
  - 악셀을 만드는데 악셀을 밝으면 뒤로 가도록 하지 않도록 하는 것



### ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
  - 자동차 인터페이스 하나만 있으면 너무 크다
    - 운전, 정비 인터페이스 두 가지로 구분한다.
    - 사용자 인터페이스를 운전자, 정비사에 맞게 하면, 각 문제를 해결하는데 원하는 것만 딱 딱 수정하면된다.
- 분리하면 하나의 인터페이스를 바꿔도 다른 것에 영향을 주지 않는다.
- 인터페이스가 명확해지고 대체 가능성이 높아진다.



### DIP 의존관계 역전 원칙

- 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다.

- 구현 클래스에 의존하지 말고 **인터페이스에 의존**하라는 뜻이다.

  - 역할에 충실해라
  - 역할과 구현을 철저하게 분리해서 설계를 해야한다.
    시스템도 바로바로 바꿀 수 있도록 한다.

- 역할에 의존하게 해야한다.
  클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.

- ```java
  pulbic class MemberService {
  //  private MemberServiceRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();
  }
  ```

  - MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.
  - 의존한다는 것은 안다는 것이다. 이 MemberService 클라이언트는 memberRepository라는 추상화에 의존하고 있지만 동시에 JdbcMemberRepository 라는 구체화에도 의존하고 있다.
  - DIP 위반!



## 정리!

- 객체 지향의 핵심은 다형성이다.
- 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
  - 다형성 만으로 구현객체를 변경할 때는 클라이언트 코드도 함께 변경되기 때문이다.
- 다형성만으로는 OCP, DIP를 지킬 수 없다.
  - 뭔가가 더 필요하다.
    - 뭘 어떻게 해야 그것을 사용할 수 있을까?





## Spring!

- spring 은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.
  - DI(Dependency Injection) : 의존관계 의존성 주입
  - DI 컨테이너 제공
    - 자바 객체들을 컨테이너 안에 넣어서 의존관계들을 연결하고 주입해주는 것
- 클라이언트 코드의 변경없이 기능 확장을 가능하게 해준다.



### 스프링...없었다면?

- 객체지향 개방을 하려고 하다보면 너무 할 일이 많았다.
- 결국 스프링으로 돌아가게 될 것이다.
  - 개발을 해보면 왜 필요한지를 알게 된다.



## LAST 정리

- 모든 설계에 역할과 구현을 분리하자.
- 모든 설계에 인터페이스를 부여하는 것이 이상적이다.
- 변경의 범위가 작고 유연해진다.
- 고민!
  - 인터페이스를 무분별하게 남발하면 추상화라는 비용이 발생한다.
    - 추상화라는 것은 개발자 코드를 한번 더 열어봐야 한다.
    - 에러가 나면 코드를 한번 더 까봐야한다.
    - 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고 향후에 필요할 때 리팩터링을 하는 것이 방법이다.

